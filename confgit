#!/usr/bin/env python

import argparse
import zipfile
from os import path, walk, getcwd, chdir, popen
import yaml
import datetime
from colorama import Fore, Back, Style


DEFAULT_CONFIG_PATH = "~/.config/confgit.yml"


def init(repo_dir, config_path):
    chdir(path.realpath(repo_dir))
    execute_command("git init")
    if not path.isfile(config_path):
        with open(config_path, "w") as new_config:
            new_config.write(
                f"exclude: null\n\ninclude: null\n\nrepo_dir: {getcwd().replace(path.expanduser('~'), '~')}"
            )
        cg_print(f"New config file generated: {config_path}")
    else:
        print_warning(f"Config file {config_path} already exists")


def sync():
    # git pull
    # nakopírovat configy na originy
    pass


def update():
    # nakopírovat configy na jejich
    pass


def backup(repo_dir, backup_name):
    if backup_name[-4:] != ".zip":
        backup_name += ".zip"
    backup_zip_file = zipfile.ZipFile(backup_name, mode="w", compression=zipfile.ZIP_DEFLATED)
    cg_print("Creating backup:")
    
    for root, directories, files in walk(repo_dir):
        for i, filename in enumerate(files):
            print(f"\t\t{'├── ' if i < len(files) - 1 else '└── '}{filename}")
            backup_zip_file.write(path.join(root, filename), arcname=filename)
    backup_zip_file.close()
    cg_print(f"Backup saved as {backup_name}")


def include(config_path, file):
    if file == "":
        print_error("no file specified")
    if config["include"] is None:
        config["include"] = []
    if file in config["include"]:
        cg_print(f"{file} is already included")
        return
    config["include"].append(file)
    with open(config_path, "w") as f:
        yaml.dump(config, f, default_flow_style=False)


def exclude(file):
    pass


def get_arguments():
    parser = argparse.ArgumentParser(
        prog="confgit",
        description="Git overhead for version control of your config files",
        formatter_class=argparse.RawTextHelpFormatter,)

    parser.add_argument(
        "-s", "--sync",
        action="store_true",
        help="update original config files from their git copies")
    parser.add_argument(
        "-u", "--update",
        action="store_true",
        help="update repo config files from original copies")
    parser.add_argument(
        "-b", "--backup",
        type=str,
        action="store",
        nargs="?",
        dest="BACKUP",
        const=f"confgit-backup-{str(datetime.datetime.now()).replace(' ','-')}.zip",
        default=False,
        help="create zip file with config backup")
    parser.add_argument(
        "-i", "--include",
        type=str,
        action="store",
        dest="INCLUDED_FILE",
        help="include file or directory in to confgit repository")
    parser.add_argument(
        "-e", "--exclude",
        type=str,
        action="store",
        dest="EXLUDED_FILE",
        help="exclude file or directory from confgit repository")
    parser.add_argument(
        "--init",
        type=str,
        action="store",
        nargs="?",
        const=str(getcwd()),
        default=False,
        dest="INIT",
        help="init confgit repository")
    parser.add_argument(
        "-c", "--config",
        type=str,
        default=DEFAULT_CONFIG_PATH,
        dest="CONFIG_PATH",
        help="load alternative config"
    )
    arguments = vars(parser.parse_args())
    arguments["CONFIG_PATH"] = relative_path_to_absolute_path(arguments["CONFIG_PATH"])
    return arguments


def execute_command(command):
    cg_print(popen(command).read().strip())


def cg_print(msg):
    print(f"{Back.GREEN + Fore.BLACK}CONFGIT:{Style.RESET_ALL} {msg}")


def print_error(msg):
    cg_print(f"{Fore.RED}ERROR:{Style.RESET_ALL} {msg}")


def print_warning(msg):
    cg_print(f"{Fore.LIGHTRED_EX}WARN:{Style.RESET_ALL} {msg}")


def load_config(config_file_path, parse_paths=True):
    try:
        with open(config_file_path, 'r') as stream:
            raw_config = yaml.safe_load(stream)
            if parse_paths:
                raw_config["repo_dir"] = relative_path_to_absolute_path(raw_config["repo_dir"])
            if raw_config["include"] is not None:
                parsed = []
                for i in raw_config["include"]:
                    parsed.append(relative_path_to_absolute_path(i, add_pwd=False))
                raw_config["include"] = parsed
            if raw_config["exclude"] is not None:
                parsed = []
                for e in raw_config["exclude"]:
                    parsed.append(relative_path_to_absolute_path(e, add_pwd=False))
                raw_config["exclude"] = parsed
            return raw_config
    except yaml.YAMLError as exc:
        print_error(f"Yaml parse of {config_file_path} failed")
        exit(1)
    except IOError as exc:
        print_error(f"File {config_file_path} does not exists")
        exit(1)


def relative_path_to_absolute_path(rp, add_pwd=True):
    if "/" not in rp:
        if add_pwd:
            rp = str(getcwd()) + "/" + rp
        else:
            rp = str(path.expanduser("~")) + "/" + rp
    return rp.replace("~", str(path.expanduser("~")))


if __name__ == '__main__':
    args = get_arguments()

    if args["INIT"]:
        init(args["INIT"], args["CONFIG_PATH"])

    config = load_config(args["CONFIG_PATH"], parse_paths=True)
    if args["BACKUP"]:
        backup(config["repo_dir"], args["BACKUP"])

